"git init"
This command initialize the git repo into your local directory. A .git folder gets created.

"git config user.name" and "git config user.email"
This command help you check which git email and username is configured to git. They don't need to be exactly of your github or gitlab email or username.

"git config --global user.name" and "git config --global user.email"
Helps in checking globally.

"ls"
To list all the files

"ls -al"
To list all the hidden files (All files starting with '.' are in general hidden)

"git add <file> "
This helps to put the file from non-staging area to the staging area. But still git is not tracking the files.

"git status"
To check which files are staged and which are not.

"git commit"
It will open an editor where u can type your commit and just can close it. Ultimately this command help git start tracking your file.

"git log"
To check the info or status of commits.

"git commit -m "Your message" "
To commit and add msg via single command.

"rm -rf .git/"
To remove the git repo locally from dir in which it was installed

"git init --initial-branch=main"
To iniitialise the git repo with branch main locally

Always make git repo inside the folder which you wanna track. Don't initialise multiple git repo in same project.

Git doesn't track empty folders.

"git status -s"
Command to show the staged files in short hand notation.

"git rm --cached <file> "
To unstage the staged files in git. Git will not track these files now.

Deep dive into a commit :-
When we do the commit a object is created that keeps 4 things-
1) User who done the commit
2) Time of commmit
3) Message of the commit
4) Snapshot of whole project

When we do the commit once, then only branch gets created.

Commits are generated by SHA1 encryption technique. (Secure Hashing Algorithm 1)

Branch has a head that points to latest commit.

All commits get stores inside the object folder of .git directory

Whenever u modify file it again comes to unstaged area.

"touch <file> "
to create a file inside the directory

"git commit --amend"
This command push the staged files into the latest commit without generating a new commit locally.

"git commit --amend --no-edit"
This command does the same but u don't need to add any message explicitly for commit.

"git commit -s -m "Your message" "
Special commit for signing off.

"git commit --allow-empty -m "Your msg" "
Empty commit. When u wanna test CI line without adding files into it.

"git log -n <no. of commits u wanna see> "
Eg. git log -n 3

"git log --pretty=fuller" or "git log --pretty=short"
All these help in getting detailed or short info about commits.

"git log --pretty=oneline" or "git log --oneline"
All commits will be diaplayed in compacted format.

"git log --since=<date> --until=<date> "
Commmits in a particular timeframe.

"git reset --soft <id of commit at which we want to return> "
Reset the changes to staged area.

"git reset --mixed <id of commit at which we want to return> "
Reset the changes to unstaged area.

"git reset --hard <id of commit at which we want to return> "
Delete the changes.

"git revert <id of latest commit from which we want to revert> "
This commit not only deletes the changes but also keep track of the history as well.

"git checkout <id or hash of the commit u wanna go> "

"git checkout main "
To return back to your latest commits. (Given that your branch is name)

"git branch"
Gives a list of branch and on which branch currently u are.

"git branch <name of branch> "
Helps in creating a new branch

"git checkout <name of branch> " or "git switch <name of branch>"
Helps in moving to a particular branch

"git branch -d <name of branch> "
To delete a branch.

"git merge <name of branch say x> "
It merges the branch x with the the branch on which you currently are. After merging both branches comes at the same level and header points to head of both the branch. It is intutive that branch x will defiitely some commits forward than current branch.

----------------------------An important scenario-------------------------
Suppose there is a main branch.
You created a new branch and commited feature 1. (one commit ahead of main branch)
Then again you created a new branch and commited feature 2. (one commit ahead of main branch)
Now,
Case 1:- You merged branch "main" and "feature 1" => No problem, both branches are at same level
But now header will point to feature 1's latest commit which is not the common root for branch "feature 2"
Case 2:- When you will merge branch "main with "feature 2" => A nw commit will be created which encompasses all the lastest changes from both branches. But make feature 1 and 2 branches to their latest commits.
Main   =>   main.py feature1.py feature2.py
Feature1  => main.py feature1.py
Feature2  => main.py feature2.py


--------Merge Conflict--------
It happens when two branches have different commits for the same file.

"git cherry-pick <hash of commit> "
To copy the particular feature from one branch to other.


